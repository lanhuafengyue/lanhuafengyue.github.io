{"meta":{"title":"蓝桦枫玥のブログ","subtitle":"","description":"","author":"蓝桦枫玥","url":"http://lanhuafengyue.github.io","root":"/"},"pages":[{"title":"404","date":"2021-02-15T15:33:28.000Z","updated":"2021-02-15T15:33:28.857Z","comments":true,"path":"404/index.html","permalink":"http://lanhuafengyue.github.io/404/index.html","excerpt":"","text":""},{"title":"About","date":"2017-06-17T16:00:00.000Z","updated":"2021-02-15T15:15:07.184Z","comments":true,"path":"about/index.html","permalink":"http://lanhuafengyue.github.io/about/index.html","excerpt":"","text":"1.博客更新时间是半个月一更2.暂不开通博客讨论区跟评论，可以私聊我B站账号3.目前颓废中ing…个人bilibili账号：https://space.bilibili.com/15064045"},{"title":"categories","date":"2021-02-15T15:34:16.000Z","updated":"2021-02-15T15:34:16.474Z","comments":true,"path":"categories/index.html","permalink":"http://lanhuafengyue.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-02-15T15:33:47.000Z","updated":"2021-02-15T15:33:47.525Z","comments":true,"path":"tags/index.html","permalink":"http://lanhuafengyue.github.io/tags/index.html","excerpt":"","text":""},{"title":"search","date":"2021-02-15T15:34:01.000Z","updated":"2021-02-15T15:34:01.700Z","comments":true,"path":"search/index.html","permalink":"http://lanhuafengyue.github.io/search/index.html","excerpt":"","text":""}],"posts":[{"title":"Math、Numpy、Scipy库速查（字典）","slug":"blog7","date":"2020-05-24T13:58:06.000Z","updated":"2020-05-24T16:49:26.717Z","comments":true,"path":"2020/05/24/blog7/","link":"","permalink":"http://lanhuafengyue.github.io/2020/05/24/blog7/","excerpt":"","text":"Math库1234567math.ceil() #向上取整math.floor()#取整数部分math.sin()、math.cos()、math.tan()math.degrees()#弧度转化为角度math.exp()#e的x次方fabs()绝对值factorial()x的阶乘 Numpy库1 Scipy库1","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://lanhuafengyue.github.io/tags/python/"}]},{"title":"Java Junit5单元测试","slug":"blog6","date":"2020-04-26T09:50:02.000Z","updated":"2020-05-24T02:31:50.144Z","comments":true,"path":"2020/04/26/blog6/","link":"","permalink":"http://lanhuafengyue.github.io/2020/04/26/blog6/","excerpt":"","text":"1.Junit5常用注解 注解 描述 @Test 表示方法是一种测试方法。 与 JUnit 4 的@Test 注解不同，此注释不会声明任何属性 @ParameterizedTest 表示方法是参数化测试 @RepeatedTest 表示方法是重复测试模板 @TestFactory 表示方法是动态测试的测试工程 @TestInstance 用于配置测试实例生命周期 @TestTemplate 表示方法是为多次调用的测试用例的模板 @DisplayName 为测试类或者测试方法自定义一个名称 @BeforeEach 表示方法在每个测试方法运行前都会运行 @AfterEach 表示方法在每个测试方法运行之后都会运行 @BeforeAll 表示方法在所有测试方法之前运行 @AfterAll 表示方法在所有测试方法之后运行 @Nested 表示带注解的类是嵌套的非静态测试类,@BeforeAll 和@AfterAll 方法不能直接在@Nested 测试类中使用，除非修改测试实例生命周期。 @Tag 用于在类或方法级别声明用于过滤测试的标记 @Disabled 用于禁用测试类或测试方法 @ExtendWith 用于注册自定义扩展，该注解可以继承 2.断言1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import static java.time.Duration.ofMillis;import static java.time.Duration.ofMinutes;import static org.junit.jupiter.api.Assertions.*;import org.junit.jupiter.api.Test;class Assert &#123; @Test void standardAssertions() &#123; assertEquals(2, 2); assertEquals(4, 4, &quot;error message&quot;); assertTrue(2 &#x3D;&#x3D; 2, () -&gt; &quot;error message&quot;); &#125; @Test void groupedAssertions() &#123; &#x2F;&#x2F;分组断言，执行分组中所有断言，分组中任何一个断言错误都会一起报告 assertAll(&quot;person&quot;, () -&gt; assertEquals(&quot;John&quot;, &quot;John&quot;), () -&gt; assertEquals(&quot;Doe&quot;, &quot;Doe&quot;) ); &#125; @Test void dependentAssertions() &#123; &#x2F;&#x2F;分组断言 assertAll(&quot;properties&quot;, () -&gt; &#123; &#x2F;&#x2F; 在代码块中，如果断言失败，后面的代码将不会运行 String firstName &#x3D; &quot;John&quot;; assertNotNull(firstName); &#x2F;&#x2F; 只有前一个断言通过才会运行 assertAll(&quot;first name&quot;, () -&gt; assertTrue(firstName.startsWith(&quot;J&quot;)), () -&gt; assertTrue(firstName.endsWith(&quot;n&quot;)) ); &#125;, () -&gt; &#123; &#x2F;&#x2F; 分组断言，不会受到first Name代码块的影响，所以即使上面的断言执行失败，这里的依旧会执行 String lastName &#x3D; &quot;Doe&quot;; assertNotNull(lastName); &#x2F;&#x2F; 只有前一个断言通过才会运行 assertAll(&quot;last name&quot;, () -&gt; assertTrue(lastName.startsWith(&quot;D&quot;)), () -&gt; assertTrue(lastName.endsWith(&quot;e&quot;)) ); &#125; ); &#125; @Test void exceptionTesting() &#123; &#x2F;&#x2F;断言异常，抛出指定的异常，测试才会通过 Throwable exception &#x3D; assertThrows(IllegalArgumentException.class, () -&gt; &#123; throw new IllegalArgumentException(&quot;a message&quot;); &#125;); assertEquals(&quot;a message&quot;, exception.getMessage()); &#125; @Test void timeoutNotExceeded() &#123; &#x2F;&#x2F; 断言超时 assertTimeout(ofMinutes(2), () -&gt; &#123; &#x2F;&#x2F; 完成任务小于2分钟时，测试通过。 &#125;); &#125; @Test void timeoutNotExceededWithResult() &#123; &#x2F;&#x2F; 断言成功并返回结果 String actualResult &#x3D; assertTimeout(ofMinutes(2), () -&gt; &#123; return &quot;result&quot;; &#125;); assertEquals(&quot;result&quot;, actualResult); &#125; @Test void timeoutExceeded() &#123; &#x2F;&#x2F; 断言超时，会在任务执行完毕后才返回，也就是1000毫秒后返回结果 assertTimeout(ofMillis(10), () -&gt; &#123; &#x2F;&#x2F; 执行任务花费时间1000毫秒 Thread.sleep(1000); &#125;); &#125; @Test void timeoutExceededWithPreemptiveTermination() &#123; &#x2F;&#x2F; 断言超时，如果在10毫秒内任务没有执行完毕，会立即返回断言失败，不会等到1000毫秒后 assertTimeoutPreemptively(ofMillis(10), () -&gt; &#123; Thread.sleep(1000); &#125;); &#125;&#125; 此实例可以看做是一个模板，在实际进行断言测试时，直接套用即可 3.假设测试1234567891011121314151617181920212223242526272829303132333435import static org.junit.jupiter.api.Assumptions.assumeFalse;import static org.junit.jupiter.api.Assumptions.assumeTrue;import static org.junit.jupiter.api.Assumptions.assumingThat;import org.junit.jupiter.api.Test;class Assumption &#123; @Test void assumeTrueTest() &#123; &#x2F;&#x2F;如果假设传入的值为True，那么就会执行后面测试，否则直接停止执行 assumeTrue(false); System.out.println(&quot;This will not be implemented.&quot;); &#125; @Test void assumeFalseTest() &#123; &#x2F;&#x2F;如果假设传入的值为false，那么就会执行后面测试，否则直接停止执行 assumeFalse(true); System.out.println(&quot;This will not be implemented.&quot;); &#125; @Test void assumingThatTest() &#123; &#x2F;&#x2F;assumingThat​(boolean assumption, Executable executable) &#x2F;&#x2F;assumingThat 接受一个boolean值assumption，如果assumption为true，那么将会执行executable，否则不会执行， &#x2F;&#x2F;但是assumingThat即使为false也不会影响后续代码的执行，他和assumeFalse和assumeTrue不同，assumingThat只 &#x2F;&#x2F;决定Executable是否执行，Executable是一个函数式接口，接受一个没有参数和返回值的方法。 assumingThat(false, () -&gt; &#123; System.out.println(&quot;This will not be implemented.&quot;); &#125;); &#x2F;&#x2F;下面的输出将会执行 System.out.println(&quot;This will be implemented.&quot;); &#125;&#125; 此实例可以看做是一个模板，在实际进行假设测试时，直接套用即可 4.条件测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.junit.jupiter.api.Test;import org.junit.jupiter.api.condition.DisabledOnJre;import org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable;import org.junit.jupiter.api.condition.EnabledIfSystemProperty;import org.junit.jupiter.api.condition.EnabledOnJre;import org.junit.jupiter.api.condition.EnabledOnOs;import org.junit.jupiter.api.condition.JRE;import org.junit.jupiter.api.condition.OS;class Condition &#123; @Test @EnabledOnJre(JRE.JAVA_8) &#x2F;&#x2F;java8 环境下运行 void javaRuntimeConditions() &#123; System.out.println(&quot;JAVA 8&quot;); &#125; @Test @DisabledOnJre(JRE.JAVA_8) &#x2F;&#x2F;除了java8其他的环境都会运行 void notONJava8() &#123; &#x2F;&#x2F; 这段代码将不会运行在java8中 System.out.println(&quot;It will not run on Java8.&quot;); &#125; @Test @EnabledOnOs(OS.LINUX) &#x2F;&#x2F;Linux系统下运行 void operatingSystemConditions() &#123; System.out.println(&quot;Running under Linux&quot;); &#125; @Test @EnabledIfSystemProperty(named &#x3D; &quot;os.arch&quot;, matches &#x3D; &quot;.*64.*&quot;) void systemPropertyConditions() &#123; &#x2F;&#x2F;在64位虚拟机下运行 System.out.println(&quot;Running on a 64 bit system&quot;); &#x2F;&#x2F;输出JVM参数列表 System.out.println(System.getProperties()); &#125; @Test @EnabledIfEnvironmentVariable(named &#x3D; &quot;USER&quot;, matches &#x3D; &quot;shiyanlou&quot;) void environmentVariableConditions() &#123; &#x2F;&#x2F;输出环境变量参数列表 System.out.println(System.getenv()); &#125;&#125; 不常用 5.@Disabled注解1234567891011121314151617import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;class DisabledTest &#123; @Test &#x2F;&#x2F;使用@Disabled注解关闭 @Disabled void disabled() &#123; System.out.println(&quot;Not running&quot;); &#125; @Test void open() &#123; System.out.println(&quot;running&quot;); &#125;&#125; 从运行结果可以看出，使用@Disabled注解的函数没有被执行 6.@Tag注解1234567891011121314import org.junit.jupiter.api.Tag;import org.junit.jupiter.api.Test;class TagTest &#123; @Test @Tag(&quot;tag1&quot;) void tag1() &#123; System.out.println(&quot;Tag1 Test&quot;); &#125; @Test @Tag(&quot;tag2&quot;) void tag2() &#123; System.out.println(&quot;Tag2 test&quot;); &#125;&#125; 在程序执行时，可以对测试用例进行选择 7.重复测试12345678910111213141516import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.RepeatedTest;import org.junit.jupiter.api.RepetitionInfo;import org.junit.jupiter.api.TestInfo;&#x2F;&#x2F;重复测试class Repeated &#123; &#x2F;&#x2F;自定义重复测试的显示名称 @RepeatedTest(value&#x3D;10,name&#x3D;&quot;&#123;displayName&#125;--&gt;&#123;currentRepetition&#125;&#x2F;&#123;totalRepetitions&#125;&quot;) @DisplayName(&quot;repeatTest&quot;) void repeatedTest(TestInfo testInfo,RepetitionInfo repetitionInfo) &#123; &#x2F;&#x2F;我们可以通过TestInfo在测试中获取测试的相关信息，比如输出自定义的测试名 System.out.println(testInfo.getDisplayName()); &#x2F;&#x2F;输出当前重复次数 System.out.println(&quot;currentRepetition:&quot;+repetitionInfo.getCurrentRepetition()); &#125;&#125; @RepeatedTest默认的显示格式是repetition {currentRepetition} of {totalRepetitions} 如果需要更改显示格式需要在@RepeatedTest注解上添加name {displayName} 表示测试的名字 {currentRepetition}表示测试的次数{totalRepetitions}表示需要测试的次数，在@RepeatedTest注解添加value属性能够指定测试次数 8.参数化测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.concurrent.TimeUnit;import java.util.stream.Stream;import org.junit.jupiter.api.extension.ExtensionContext;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.Arguments;import org.junit.jupiter.params.provider.ArgumentsProvider;import org.junit.jupiter.params.provider.ArgumentsSource;import org.junit.jupiter.params.provider.CsvSource;import org.junit.jupiter.params.provider.EnumSource;import org.junit.jupiter.params.provider.ValueSource;class ParameterTest &#123; @ParameterizedTest @ValueSource(strings&#x3D; &#123;&quot;lan&quot;,&quot;hua&quot;,&quot;feng&quot;,&quot;yue&quot;&#125;) void parameter(String args) &#123; System.out.println(args); &#125; @ParameterizedTest &#x2F;&#x2F;使用names制定需要的枚举常量 @EnumSource(value &#x3D; TimeUnit.class, names &#x3D; &#123; &quot;DAYS&quot;, &quot;HOURS&quot; &#125;) void enumSource(TimeUnit timeUnit) &#123; System.out.println(timeUnit.toString()); &#125; @ParameterizedTest @CsvSource(&#123; &quot;shi, 1&quot;, &quot;yan, 2&quot;, &quot;&#39;lou, plus&#39;, 3&quot; &#125;) void csvSource(String first, int second) &#123; System.out.println(first+&quot;---&quot;+second); &#125; @ParameterizedTest @ArgumentsSource(MyArgumentsProvider.class) void argumentsSource(String argument) &#123; System.out.print(argument);; &#125; static class MyArgumentsProvider implements ArgumentsProvider &#123; @Override public Stream&lt;? extends Arguments&gt; provideArguments(ExtensionContext context) &#123; return Stream.of(&quot;shi-&quot;, &quot;yan-&quot;, &quot;lou\\n&quot;).map(Arguments::of); &#125; &#125;&#125; 参数注解 描述 @ValueSource 允许指定单个文字值数组，并且只能用于为每个参数化测试调用提供单个参数 @EnumSource 提供了一种使用 Enum 常量的便捷方法 @MethodSource 允许引用测试类或外部类的一个或多个工厂方法返回值必须是一个 Stream、Iterable、Iterator 或者参数数组。 @CsvSource 允许将参数列表定义为以逗号分隔的值","categories":[{"name":"java","slug":"java","permalink":"http://lanhuafengyue.github.io/categories/java/"}],"tags":[]},{"title":"idea使用Maven创建SpringMVC项目详解","slug":"blog5","date":"2020-01-28T09:49:56.000Z","updated":"2020-05-24T02:30:24.152Z","comments":true,"path":"2020/01/28/blog5/","link":"","permalink":"http://lanhuafengyue.github.io/2020/01/28/blog5/","excerpt":"","text":"具体创建过程如下： 使用快速创建maven项目 输入初试包的名称以及项目名 选择maven，这里推荐使用本地安装的maven，如果你没有代理的话，创建项目容易超时，初次使用maven时应注意在初始化的时候至少有28个以上文件才算初始化成功，保证今后创建的项目不会出错 这里输入的项目名应该和一开始输入的名字保持一致，不然在项目运行时会出现两个项目 1是初始化后的文件目录结构，这并不是Spring项目，只是一个简单的maven项目而已，2是配置文件，在这个文件我们可以添加所使用的依赖，当然使用dependence标签，我们可以在 https://mvnrepository.com/ 找到我们所需要的任何依赖，直接复制进去就可以了，3如果你是第一次使用maven那么创建速度会很慢，等一段时间就好了，第一次加载完成后一定要查看自己的仓库文件大于等于28个为正常，文件数目不对需要重新创建项目重复上述步骤，直到成功 在main文件下创建resources文件夹，然后改成Resources Root 先在pom.xml文件中添加spring-webmvc依赖，然后在 resources创建META-INF文件夹，在这个文件夹低下创建spring config，命名为applicationContext.xml 打开applicationContext.xml文件，按照提示创建点击ok，到此为止一个Spring项目就算搭建完成了 12345678910111213141516171819202122232425262728293031323334353637383940414243&#x2F;&#x2F;现在是这是Spring创建完成后测试代码Hello.javapackage com.hello;public class Hello &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; public void show()&#123; System.out.println(&quot;hello &quot;+name); &#125;&#125;Main.javapackage com.hello;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Main &#123; public static void main(String[] args)&#123; ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;META-INF&#x2F;applicationContext.xml&quot;); Hello hello &#x3D; (Hello)context.getBean(&quot;hello&quot;); hello.show(); &#125;&#125;applicationContext.xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.hello.Hello&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;spring&quot; &#x2F;&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; 点击运行出现以下内容表示Spring项目搭建完成","categories":[{"name":"java","slug":"java","permalink":"http://lanhuafengyue.github.io/categories/java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://lanhuafengyue.github.io/tags/Spring/"}]},{"title":"Matlab跟Octave快速入门以及常用命令总结","slug":"blog2","date":"2020-01-28T09:47:00.000Z","updated":"2020-05-24T02:27:17.645Z","comments":true,"path":"2020/01/28/blog2/","link":"","permalink":"http://lanhuafengyue.github.io/2020/01/28/blog2/","excerpt":"","text":"Matlab跟Octave是数值分析的基础，在初学者学习机器学习，深度学习时不妨可以使用他们，相对于python Numpy，R他们能够更快更好的学习、理解算法，Matlab软件具有很强大的功能，机器学习，深度学习，仿真，数据挖掘等等，能够做很多，Octave则是一款开源软件，相对于Matlab功能上没有其强大，但其语法与Matlab十分相似，安装的空间也没有Matlab那样大，对于需求没有特别大的初学者，更建议使用Octave。以下是对Matlab跟Octave常用命令的总结。 A = [1 2 3;4 5 6;7 8 9]会输出一个3 * 3 的矩阵，每一个分号代表一行，并且这个矩阵会在显示在命令窗口中。A = [1 2;3 4;5 6];会得到一个2*3的矩阵跟上面不同，如果带分号是不会再命令窗口中显示的当然A = [1 2 3]会得到一个行向量，A’表示A的转置。 A = 1:5会得到一个行向量相当于A = [1 2 3 4 5]A = 1:0.5:5相当于A = [1 1.5 2 2.5 3 3.5 4 4.5 5]中间的数字代表间隔ones(2,3)会得到一个值全部为1的2 * 3的矩阵，当然zeros(2,3)同理，会得到一个全部为0的2*3矩阵A(2,3)会找到第二行第三列的元素，A(2,:)会显示第二行的所有元素，同样A(:,2)会显示第二列所有元素，A([1,3],:)会显示第一第三行的所有元素，A(1,:)=[1,2,3]会替换第一行的元素，同样A(:,1)=[1;2;3]会替换第一列的元素，A = [A,[1；2；3]]表示给A添加一列列向量，A(:)把A中的所有元素放在一个列向量C = [A B]把AB两个矩阵合在一起 rand(1,10)随机生成一个1行10列的随机矩阵，randn(1,10)随机生成一个高斯随机变量，服从高斯分布，eye(x)生成x阶单位矩阵。size(x)返回矩阵x的列跟行 load(“文件路径+名字”)加载文件，who可以输出工作空间中的所有变量参数，whos显示更详细的信息，save 文件名，会保存你的数据到一个文件中 log()取对数exp()取指数abs()绝对值max()最大值max(A,[],2) 会找到每一行的最大值max(A,[],1)会找到每一列的最大值find()找到符合条件的数，返回下角标sum()求和floor()取整ceil()向上取整flipud(A)把A矩阵翻转pinv(A)求A的逆矩阵 hist(x)绘制平方图plot(x,y,’color’)绘制二维图形xlabel()，ylabel()，legend()，title()分别是给X轴表示的含义，y轴表示的含义，标题，图中每个区曲线的含义subplot(1,2,1)划分格子，表示一行，两个格子，现在用第一个格子画图axis([0.5 1 -1 1])表示可看见的坐标的范围x轴为0.51，y轴为-11 还会后续补充ing。。。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://lanhuafengyue.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"英语一大作文模板（万能）","slug":"blog4","date":"2020-01-22T09:49:50.000Z","updated":"2020-05-24T02:28:13.723Z","comments":true,"path":"2020/01/22/blog4/","link":"","permalink":"http://lanhuafengyue.github.io/2020/01/22/blog4/","excerpt":"","text":"The past several years have witenessed a social phenonmenon that it is great importance of (主题词). As is shown in this picture,(图画描述).The authors real purpose is not fact itself, but to lead us to finnd what hide behind the picture. Actuallt, the author strives to send out an abunndantly clear message that (主题句).As Dawna Markova, director of information service at General Service Administration, put it ,”It can not be denied, under any circumstance,that (主题句)” These seem to be more than one director or indirector effects involved in persistance which none of us can fail to notice.First,….Second,…..Were there no such things,we may never taste a color life. In view of every aspect of this phenonmenon,we should bear in mind that (主题句).As for ourselves, we ought to take practical actions to improve (主题词).The public should enhance consi=ciousness of persistance only in this way can we come across various challenges. 五大万能理由：1： 2： 3： 4： 5： 主题词大全：self-confidence自信，lack of confidence缺乏自信，aggressive进取心，teamwork团队合作，persistence坚持，respect the old and care for the young尊老爱幼，honesty诚信，action行动，environmental awareness环境意识，university graduates大学毕业生，support the elderly赡养老人，spoil children溺爱孩子，responsibility责任，devotion奉献，the cultural fusion文化融合，cultural exchanges文化交流。 最后准备：最后两个月快速过一遍看看颉斌斌的作文课","categories":[],"tags":[]},{"title":"我的大学四年生活","slug":"blog3","date":"2020-01-01T09:48:35.000Z","updated":"2020-05-24T02:27:46.292Z","comments":true,"path":"2020/01/01/blog3/","link":"","permalink":"http://lanhuafengyue.github.io/2020/01/01/blog3/","excerpt":"","text":"刚入大学，我也是怀着跟你们一样同样的心情步入的大学校门，军训，学生会，社团，我可以说可以体验的东西我在大一的时候都体验了一把，跟我在同一所学校读书的人可能没有人能够有比我更深的体会。 我在10月的时候加入了校学生会宣传部，我也加了唯一的一个社团，心理协会，这个社团你们可能没有听说过吧，不过并不重要。可以说我大一整个一年的精力都在这些地方进行了输出，旷课，逃课，挂科，我都经历过。没有任何的实体感每一天可以说就是这么的颓废，现在回头想想不知道自己大一究竟在干什么，你们可能体会不到吧，等你们大四的时候回忆回忆自己的大一大二，估计跟我一样的感受。 我先来说一下，我在学生会得到了什么，当然答案显而易见，只有一纸证书，证明你在这里待过。如果你说我在说谎的话，我可以很明确的告诉你，我没有，我玩了学校一年的相机跟设备，玩的很开心。我可以很明白的说，我大一的时候几乎就没有学习过吧，对这个行业，对这个专业完全的小白，你不要觉得我现在编程什么的都还凑活，都是在后续的努力追上来的。 我当初在大一下学期就决定离开了学生会，不会再在这个地方浪费我一年的时间了，即使给我再多的好处，意义并不是很大，经过我四年的观察，我发现我的决定是非常正确的。 这一年我选择留在了社团，原因很简单，这个社团有一个独立的办公室（教辅楼四楼，宿舍环境你们懂吧），并且门的钥匙就在我的手上，我可以随时过去，学习，补习，这才赶上很多专业课，并且我在大二的上个学期就开始着手准备考研，虽然我并不知道这是个什么，每天看着某网红老师的相声，但是也是这个吧，我知道了我为什么要提升学历，为了什么去考研。 大二上学期，我补习了C语言，数据结构这两门课，我在学习过程中并不清楚这两门课程会给我的就业，我的专业带来什么，因为我当时只有一个念头，就是把浪费的大一一年的时间补习回来，不出意外，我大二上学期的努力也算得到了一些回报，成功的捡回了一些基础，但是我当时并不知道，算法是什么，这个究竟有什么用，换句话说，我只是进行了学习，盲目的学习。 每个人都会有迷茫期，我也不意外，只不过我可以说很幸运，2017年我决定的考研，当时我的目标很大，也很明确，北理工这样的顶级名校吧。在一系列的准备中，我清楚的感觉到了自身与一本学校的学生，跟985，211学校的差距，我当时感到很后悔，很后悔来到这个地方，但是我现在回想起来，其实也不算后悔，周围的老师对我有过一定的帮助。 大二的下学期我才知道算法这个东西，知道了蓝桥杯，知道了许许多多的一系列知名的算法比赛，我也是在大二下学期开始有想法参与这些比赛中。 大二的一年可以说是我的转折点，我接触了非常多的东西跟许多的新鲜事物，数学建模，程序竞赛，人工智能，区块链等等。这一年我除了对人工智能一知半解以外，对其他基本上了解的相对深入，大二下学期，我参加了数学建模，在暑假，因为我一个同学的原因，我接触到了对区块链了解更深入的研发团队，并且去亲自体会了他们的交流大会，虽然我是个小白，被同学被迫拉着过去的。但是我也学习了很多东西，认识了真正的大牛，也了解了市场，这个团队区块链项目现在你在github上也可以搜索到EOS-FORCE，有兴趣的可以看一看。 大三一年我基本都是活跃在竞赛中，蓝桥杯，数学建模比赛，河北省程序设计比赛，还有数学竞赛，基本上学校里我能参加的，知道多会儿能参加的我基本上都有参与。至于结果，我想大多数人都知道吧，数学竞赛省一，河北省程序设计比赛省三，外加一个失误严重的蓝桥杯省三，这基本上就是我大学过程中的全部竞赛了。除了参加比赛，我剩下的时间都复习考研了，我目标也很明确。","categories":[],"tags":[{"name":"经验","slug":"经验","permalink":"http://lanhuafengyue.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"大学","slug":"大学","permalink":"http://lanhuafengyue.github.io/tags/%E5%A4%A7%E5%AD%A6/"}]},{"title":"考研！对于二本三本的学生来说什么时间开始复习更合适？","slug":"blog1","date":"2019-11-05T09:06:52.000Z","updated":"2020-05-24T02:26:26.343Z","comments":true,"path":"2019/11/05/blog1/","link":"","permalink":"http://lanhuafengyue.github.io/2019/11/05/blog1/","excerpt":"","text":"我们可以先看下面的两张图片 某三本院校的考研上线人数 某一本院校的考研上线人数 从上面我们可以很直观的看出研究生录取的差距，对于三本院校来说录取人数感人，而普通一本院校的录取人数在三本的10倍往上，也就是说，一本的一个院系的录取人数就远超三本院校的全校录取人数，学习氛围差距如此之大，那么对于一个普通二本三本的学生在基础薄弱的条件下，我们应该如何准备并且何时准备考研才能提高我们考上的几率呢？ 首先我们要明确自己的目标，知道自己究竟为什么要去考取研究生，如果你只是一味的跟随别人的脚步，周围的人都在考研究生，我也要考的态度，那么身处二本三本的你考上的几率渺然。其次，如果身为二本三本院校的你，在前三年都没有努力学习的情况下，想要通过一年的努力就要考上研究生来弥补你这三年所浪费掉的时间的话，我可以很负责的说，几乎不可能，你在学校所学习的专业知识深度跟基础本来就跟一本学生相差甚远，前三年的你本来就没有进行过多的学习，你努力人家比你更努力，所以你觉得你能追赶上来吗？我觉得这是不可能的事实。因此我个人觉得如果想要考上研究生，你需要比他们多复习半年，利用半年的时间来纠正你在大学期间的学习态度，然后利用一年的时间进行完整的规划跟复习，不敢说你可以考上多好的学校，有个学上还是没问题的，应该可以达到顶级双非院校还有普通一本问题还是不大的。 如果你的专业是热门专业比如计算机金融等，或者你的专业课李有数学，你还处于二本三院校，那么你一定能够要在大三上学期就要考试进行数学的复习，不在这个范围内的学生，最晚也需要寒假就考试复习，这是数学这门学科的底线，对你的成绩有着最直接的影响，如果没有数学这门学科，你所处的专业是冷门专业，深处二本三本的你也需要在大三上学期 的十一月就开始进行复习，这是最明智也是最明确的选择。","categories":[],"tags":[{"name":"经验","slug":"经验","permalink":"http://lanhuafengyue.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"大学","slug":"大学","permalink":"http://lanhuafengyue.github.io/tags/%E5%A4%A7%E5%AD%A6/"}]}],"categories":[{"name":"java","slug":"java","permalink":"http://lanhuafengyue.github.io/categories/java/"}],"tags":[{"name":"python","slug":"python","permalink":"http://lanhuafengyue.github.io/tags/python/"},{"name":"Spring","slug":"Spring","permalink":"http://lanhuafengyue.github.io/tags/Spring/"},{"name":"机器学习","slug":"机器学习","permalink":"http://lanhuafengyue.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"经验","slug":"经验","permalink":"http://lanhuafengyue.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"大学","slug":"大学","permalink":"http://lanhuafengyue.github.io/tags/%E5%A4%A7%E5%AD%A6/"}]}